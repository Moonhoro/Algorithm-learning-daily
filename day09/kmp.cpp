/*一、题目描述
给定一个模式串 S,以及一个模板串 P，所有字符串中只包含大小写英文字母以及阿拉伯数字。
模板串P在模式串S中多次作为子串出现。
求出模板串P在模式串S中所有出现的位置的起始下标。
输入格式
第一行输入整数 N，表示字符串P的长度。

第二行输入字符串 P。

第三行输入整数 M，表示字符串 S的长度。

第四行输入字符串 S。

输出格式
共一行，输出所有出现位置的起始下标（下标从 0开始计数），整数之间用空格隔开
*/
#include<iostream>

using namespace std;

const int   N=10010,M=100010;
int n,m;
//p为待匹配字符串，S为主串
char p[N],S[M];
//ne数组为next数组，ne[i]表示p[i]之前的字符串中有多大长度的相同前缀后缀 也为跳过字符的个数
int ne[N];
int main()
{
    cin>>n>>p+1>>m>>S+1;//下标从1开始
//求next的过程
for(int i=2,j=0;i<=n;i++)
{
    //如果不匹配，跳过ne[j]个字符，继续匹配
    while(j&&p[i]!=p[j+1])j=ne[j];
    //如果匹配，j++
    if(p[i]==p[j+1])j++;
    //更新ne[i]，表示p[i]之前的字符串中有多大长度的相同前缀后缀，也为跳过的字符数
    ne[i]=j;
}
//匹配过程
for(int i=1,j=0;i<=m;i++)
{
    while(j&&s[i]!=p[j+1])j=ne[j];
    if(s[i]==p[j+1])j++;
    if(j==n)//匹配成功
    {
        cout<<i-n<<' ';
        j=ne[j];
    }
}
    return 0;
}